<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../imports.html">
<link rel="import" href="../hc-ns.html">

<script>
    
    HighChartsElement.SUPPORTED_CHART_TYPES = {
        LINE:           'line'
        , SPLINE:       'spline'
        , BAR:          'bar'
        , COLUMN:       'column'
        , AREA:         'area'
        , AREASPLINE:   'areaspline'
        , SCATTER:      'scatter'
        , BUBBLE:       'bubble'
    };
     
   /**
    * `HighChartsElement.Common` holds acts as a base class and has properties and 
    * methods inherited by all chart types.
    *
    * @polymerBehavior HighChartsElement.Common
    **/
    HighChartsElement.CommonImpl = {
        
        properties: {
            
            width: {
              type: Number,
              value: null,
              observer: '_resize'
            }
            
            , height: {
              type: Number,
              value: null,
              observer: '_resize'
            }
        
            , options: {
              type: Object,
              value: null
            }
        
            , type: {
              type: String,
              value: 'bar'
            }
            
            , title: {
              type: String,
              value: ''
            }
            
            , subtitle: {
              type: String,
              value: ''
            }
            
            , credits: {
              type: Boolean,
              value: false
            }
            
            , animation: {
              type: Boolean,
              value: true
            }
            
            , hideLegend: {
              type: Boolean,
              value: false
            }
            
            , hideLabels: {
              type: Boolean,
              value: false
            }
            
            , reflow: {
              type: Boolean,
              value: false
            }
            
            , exporting: {
              type: Boolean,
              value: false
            }
            
            , colors: {
                type: Array,
                value: null
            }
            
            , series: {
                type: Array,
                value: null,
                observer: '_updateData'
            }
            
            , debug: {
              type: Boolean,
              value: false
            }
            
            , resizeDuration: {
              type: Number,
              value: 250
            }
            
            , _isResizing: {
              type: Boolean,
              value: false
            }
        }
        
        , _chart: null
        
        , getChart: function() {
            return this._chart;
        }
        
        , _getChartElement: function() {
            return this.$.chartContainer;
        }
        
        , _commonChartOptions: function(options) { var self = this;
            // Handle common properties (TODO: Maybe deep merging)
            options.chart.renderTo     = self._getChartElement()
            options.chart.width        = (self.width?self.width:null)
            options.chart.height       = (self.height?self.height:null)
            options.chart.animation    = self.animation;
            options.chart.reflow       = self.reflow;
            
            options.exporting          = self.exporting;
            if(!options.credits) { options.credits = {}; }
            options.credits.enabled    = self.credits;
            
            if(!options.title) { options.title = {}; }
            options.title.text = self.title;
            
            if(!options.subtitle) { options.subtitle = {}; }
            options.subtitle.text = self.subtitle;
            
            if(!options.legend) { options.legend = {}; }
            options.legend.enabled = !self.hideLegend;
            
            return options;
        }
        
        , ready: function() { var self = this;
            self.async( function(){ var self = this;
                self.render();
            }.bind(self), 1);    
        }
        
        , render: function() { var self = this;
            if(!self.series){
                return;
            }
            if(!self._chart) {
                var chartOptions = self._commonChartOptions( self._createChartOptions());
                if(typeof self._setChartStackingOptions==='function'){
                    self._setChartStackingOptions(chartOptions);
                }
                
                if(self.debug) {
                    console.debug("highcharts-element options object: %o", chartOptions); 
                }
                
                // Merge in override options
                if(typeof self.options === 'string') {
                    try {
                        self.options = JSON.parse(self.options);
                    } catch(ex){
                        console.error("Exception thrown parsing options attribute: "+ ex);
                    }
                }
                
                if(typeof self.options === 'object') {
                    chartOptions = Highcharts.merge(chartOptions, self.options);
                }
                
                self._chart = new Highcharts.Chart(chartOptions);
            } else {
                try {
                    self._chart.series = self.series;
                    // self._chart.series[0].setData(self.series);
                }catch(ex){
                    console.error("Exception thrown updating chart data %o", ex);
                }
            }
        }
        
        , _resize: function() { var self = this;
            self.async( function(){ var self = this;
                if(self._chart){
                    try {
                        self._isResizing=true;

                        // Resize container
                        var chartCon = self._getChartElement();
                        chartCon.style.width  = self.width+'px';
                        chartCon.style.height = self.height+'px';
                        
                        // This is how you get the nice dynamic
                        // resizing effect
                        self._chart.setSize(
                            self.width
                            , self.height
                            , {duration: self.resizeDuration}
                        );

                        // Hack because 'sometimes' this element does
                        // not expand the width of parent, weird 
                        // because the numbers in setResize() below are correct

                        var hcCon = self.querySelector('.highcharts-container');
                        hcCon.style.width  = self.width+'px';
                        hcCon.style.height = self.height+'px';
                        
                    } catch(ex) {
                        console.log('hc-common behavior: Error on resize '+ex);
                    }
                    self._isResizing=false;
                }
            }.bind(self), 1);  
        }
       
        , _updateData: function(newData, oldData) { var self = this;
            self.async( function(){ var self = this;
                if(self._chart){
                    try {
                    
                        // self._chart.options.series = newData;
                    
                        var elementType = self.nodeName;
                        if(elementType === 'HC-GAUGE') {
                        
                            self._chart.series[0].setData(newData[0].data);
                            
                            // Get the point
                            var point = self._chart.series[0].data[0];
                            
                            // Update value
                            point.dataLabel.attr({ text: self._getGaugeDataLabelFormat(self._chart.options) });
                            
                        } else if(elementType === 'HC-GAUGE-SEMI') {
                        
                            
                            self._chart.series[0].dataLabelsGroup.div.innerHTML = self._getSemiGaugeDataLabelFormat(self._chart.options);
                            self._chart.series[0].setData([500000]);
                            self._chart.redraw();
                            
                        } else {
                            
                            self._chart.series.forEach( function(el, i, list) {

                                // Update the name only, not data yet
                                el.update({name:newData[i].name}, false);
                                self._chart.redraw(); // Need this here, or data doesn't update

                                // Have to update points to get smooth transitions
                                if(false) {
                                    
                                    // Note, this only gives smooth transitions 
                                    // if not adding new points also
                                    el.setData(newData[i].data);
                                    el.drawDataLabels();
                                    self._chart.redraw();
                                    
                                } else {
                                    /*
                                    el.data.forEach( function(point, pi, list) {
                                        point.update(newData[i].data[pi], false);
                                    });
                                    */
                                    el.setData( newData[i].data.slice(0,el.data.length) );
                                    self._chart.redraw();

                                    // Data Labels ( or gauge center number does not change )
                                    el.drawDataLabels();
                                    self._chart.redraw();
                                    
                                    // Now need to add any new points
                                    // This way we still get smooth transitions for new points
                                    var lengthDiff = newData[i].data.length-el.data.length;
                                    if(lengthDiff>0) {
                                        for (npi = 0; npi < lengthDiff; npi++) { 
                                            var index = el.data.length+npi;
                                            el.addPoint(newData[i].data[index], true, true);
                                        }
                                    }
                                }
                            });
                        }
                      
                    } catch(e) {
                        console.log('hc-common behavior: Error updating data '+e);
                    }
                }
            }.bind(self), 1);  
        }
    };
    
    HighChartsElement.Common = [HighChartsElement.CommonImpl];
</script>